<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Preview</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .markdown-body h1 {
            font-size: 2em;
            font-weight: bold;
            border-bottom: 1px solid #d1d5db;
            padding-bottom: 0.3em;
            margin-bottom: 16px;
        }

        .markdown-body h2 {
            font-size: 1.5em;
            font-weight: bold;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.3em;
            margin-top: 24px;
            margin-bottom: 16px;
        }

        .markdown-body h3 {
            font-size: 1.25em;
            font-weight: bold;
            margin-top: 24px;
            margin-bottom: 16px;
        }

        .markdown-body h4 {
            font-size: 1em;
            font-weight: bold;
            margin-top: 24px;
            margin-bottom: 16px;
        }

        .markdown-body p {
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .markdown-body hr {
            border: none;
            border-top: 2px solid #d1d5db;
            margin: 24px 0;
        }

        .markdown-body ul {
            list-style: disc;
            padding-left: 2em;
            margin-bottom: 16px;
        }

        .markdown-body ol {
            list-style: decimal;
            padding-left: 2em;
            margin-bottom: 16px;
        }

        .markdown-body li {
            margin-bottom: 4px;
            line-height: 1.6;
        }

        .markdown-body code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #1e293b;
        }

        .markdown-body pre {
            background: #1e293b;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 16px;
        }

        .markdown-body pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        .markdown-body strong {
            font-weight: 700;
        }

        .markdown-body blockquote {
            border-left: 4px solid #d1d5db;
            padding-left: 16px;
            color: #6b7280;
            margin-bottom: 16px;
        }

        .markdown-body a {
            color: #60a5fa;
            text-decoration: underline;
        }

        .markdown-body img {
            max-width: 100%;
        }

        .markdown-body table {
            border-collapse: collapse;
            margin-bottom: 16px;
            width: 100%;
        }

        .markdown-body th,
        .markdown-body td {
            border: 1px solid #374151;
            padding: 8px 12px;
        }

        .markdown-body th {
            background: #1e293b;
            font-weight: 600;
        }

        #editor {
            background: #0f172a;
            color: #86efac;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            border: none;
            tab-size: 4;
        }

        #editor::placeholder {
            color: #4b5563;
        }

        #editor::-webkit-scrollbar,
        #preview-panel::-webkit-scrollbar {
            width: 8px;
        }

        #editor::-webkit-scrollbar-track,
        #preview-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        #editor::-webkit-scrollbar-thumb,
        #preview-panel::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 4px;
        }

        #editor::-webkit-scrollbar-thumb:hover,
        #preview-panel::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }

        .divider {
            width: 6px;
            cursor: col-resize;
            background: #1e293b;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .divider:hover,
        .divider.active {
            background: #3b82f6;
        }

        .settings-dialog {
            animation: settingsFadeIn 0.15s ease-out;
        }

        @keyframes settingsFadeIn {
            from {
                opacity: 0;
                transform: translateY(-4px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Preview cursor (blinking caret) */
        .preview-cursor {
            display: inline;
            position: relative;
        }

        .preview-cursor::after {
            content: '';
            display: inline-block;
            width: 2px;
            height: 1.15em;
            background: #60a5fa;
            vertical-align: text-bottom;
            animation: cursorBlink 1s step-end infinite;
            margin-left: -1px;
            margin-right: -1px;
        }

        @keyframes cursorBlink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        /* Preview selection highlight */
        .preview-selection {
            background: rgba(96, 165, 250, 0.35);
            border-radius: 2px;
        }

        /* Settings section titles */
        .settings-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #9ca3af;
            margin-bottom: 10px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #374151;
        }
    </style>
</head>

<body class="bg-gray-950 text-gray-100 h-screen flex flex-col overflow-hidden">
    <!-- Header -->
    <div class="flex items-center justify-between px-6 py-4 border-b border-gray-800 flex-shrink-0">
        <h1 class="text-2xl font-bold text-white flex items-center gap-2">
            <svg class="w-7 h-7 text-blue-400" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path
                    d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
            Markdown Preview
        </h1>
        <div class="flex items-center gap-3">
            <button id="clearBtn" onclick="clearEditor()"
                class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-semibold px-4 py-2 rounded-lg transition cursor-pointer flex items-center gap-2 text-sm">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path
                        d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                Clear
            </button>
            <button id="copyBtn" onclick="copyMarkdown()"
                class="bg-green-600 hover:bg-green-700 text-white font-semibold px-5 py-2 rounded-lg transition cursor-pointer flex items-center gap-2 text-sm">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path
                        d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                Copy Markdown
            </button>
            <!-- Settings -->
            <div class="relative">
                <button id="settingsBtn" onclick="toggleSettings()"
                    class="text-gray-400 hover:text-white transition cursor-pointer p-2 rounded-lg hover:bg-gray-800">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path
                            d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.066 2.573c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.573 1.066c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.066-2.573c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <circle cx="12" cy="12" r="3" />
                    </svg>
                </button>
                <!-- Settings dialog -->
                <div id="settingsDialog"
                    class="hidden settings-dialog absolute right-0 top-12 bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-5 z-50 w-80">

                    <!-- General section -->
                    <div class="settings-section-title" style="margin-top:0;padding-top:0;border-top:none;">General
                    </div>
                    <div class="flex items-center justify-between">
                        <label class="text-sm text-gray-300 cursor-pointer select-none">Load example on open</label>
                        <button id="autoLoadToggle" onclick="toggleAutoLoad()"
                            class="relative w-11 h-6 rounded-full transition cursor-pointer" role="switch">
                            <span id="toggleDot"
                                class="absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full transition-transform shadow-sm"></span>
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">When enabled, a sample README will be loaded automatically
                        when you open this page.</p>

                    <!-- Realtime Sync section -->
                    <div class="settings-section-title">Realtime Sync</div>

                    <div class="flex items-center justify-between mb-1">
                        <label class="text-sm text-gray-300 cursor-pointer select-none">Cursor sync</label>
                        <button id="cursorSyncToggle" onclick="toggleCursorSync()"
                            class="relative w-11 h-6 rounded-full transition cursor-pointer" role="switch">
                            <span id="cursorSyncDot"
                                class="absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full transition-transform shadow-sm"></span>
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 mb-4">Show a blinking cursor in the preview that matches the editor
                        cursor position.</p>

                    <div class="flex items-center justify-between mb-1">
                        <label class="text-sm text-gray-300 cursor-pointer select-none">Selection sync</label>
                        <button id="selectionSyncToggle" onclick="toggleSelectionSync()"
                            class="relative w-11 h-6 rounded-full transition cursor-pointer" role="switch">
                            <span id="selectionSyncDot"
                                class="absolute top-0.5 left-0.5 w-5 h-5 bg-white rounded-full transition-transform shadow-sm"></span>
                        </button>
                    </div>
                    <p class="text-xs text-gray-500">Highlight matching text in the preview when selecting in the
                        editor.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Split View -->
    <div class="flex flex-1 overflow-hidden">
        <!-- Left: Editor -->
        <div id="editor-panel" class="flex flex-col" style="width: 50%;">
            <div class="px-4 py-2 bg-gray-900 border-b border-gray-800 flex items-center gap-2 flex-shrink-0">
                <svg class="w-4 h-4 text-green-400" fill="none" stroke="currentColor" stroke-width="2"
                    viewBox="0 0 24 24">
                    <path d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
                </svg>
                <span class="text-sm font-semibold text-gray-400">Markdown</span>
            </div>
            <textarea id="editor" class="flex-1 w-full p-5" placeholder="Type your Markdown here..."
                spellcheck="false"></textarea>
        </div>
        <!-- Draggable Divider -->
        <div class="divider" id="divider"></div>
        <!-- Right: Preview -->
        <div id="preview-wrapper" class="flex flex-col flex-1 min-w-0">
            <div class="px-4 py-2 bg-gray-900 border-b border-gray-800 flex items-center gap-2 flex-shrink-0">
                <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" stroke-width="2"
                    viewBox="0 0 24 24">
                    <path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path
                        d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                <span class="text-sm font-semibold text-gray-400">Preview</span>
            </div>
            <div id="preview-panel" class="flex-1 overflow-y-auto p-6 bg-gray-800">
                <div id="markdown-preview" class="markdown-body text-gray-200 max-w-none"></div>
                <div id="placeholder" class="flex items-center justify-center h-full text-gray-600 text-lg">
                    <span>Preview will appear here</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const preview = document.getElementById('markdown-preview');
        const placeholder = document.getElementById('placeholder');

        const sampleMarkdown = `# Markdown Preview

### Real-time Markdown Preview Tool

---

## English

A simple browser-based Markdown preview tool with a split-view editor.

- **Real-time preview**: See your Markdown rendered instantly as you type.
- **Split view**: Editor on the left, preview on the right — with a draggable divider.
- **Copy to clipboard**: One-click copy of your raw Markdown text.

> **Tip:** You can write your Markdown here, preview it, then copy and paste it directly.

---

## 日本語

ブラウザ上で動作する、スプリットビュー型のMarkdownプレビューツールです。

- **リアルタイムプレビュー**：入力と同時にMarkdownが即座にレンダリングされます。
- **スプリットビュー**：左側にエディター、右側にプレビュー — 仕切りはドラッグで調整可能です。
- **クリップボードにコピー**：ワンクリックでMarkdownテキストをコピーできます。

> **ヒント：** ここでMarkdownを作成し、プレビューを確認してから、そのまま貼り付けることができます。`;

        // ========== Settings State ==========
        let autoLoad = localStorage.getItem('md-autoload') !== 'false';
        let cursorSync = localStorage.getItem('md-cursor-sync') === 'true';
        let selectionSync = localStorage.getItem('md-selection-sync') === 'true';

        // ========== Toggle Helpers ==========
        function updateToggleUI(btnId, dotId, value) {
            const toggle = document.getElementById(btnId);
            const dot = document.getElementById(dotId);
            if (value) {
                toggle.classList.remove('bg-gray-600');
                toggle.classList.add('bg-green-500');
                dot.style.transform = 'translateX(20px)';
            } else {
                toggle.classList.remove('bg-green-500');
                toggle.classList.add('bg-gray-600');
                dot.style.transform = 'translateX(0)';
            }
        }

        function toggleAutoLoad() {
            autoLoad = !autoLoad;
            localStorage.setItem('md-autoload', autoLoad);
            updateToggleUI('autoLoadToggle', 'toggleDot', autoLoad);
        }

        function toggleCursorSync() {
            cursorSync = !cursorSync;
            localStorage.setItem('md-cursor-sync', cursorSync);
            updateToggleUI('cursorSyncToggle', 'cursorSyncDot', cursorSync);
            if (!cursorSync && !selectionSync) {
                renderPreview();
            } else {
                updateSyncOverlay();
            }
        }

        function toggleSelectionSync() {
            selectionSync = !selectionSync;
            localStorage.setItem('md-selection-sync', selectionSync);
            updateToggleUI('selectionSyncToggle', 'selectionSyncDot', selectionSync);
            if (!selectionSync && !cursorSync) {
                renderPreview();
            } else {
                updateSyncOverlay();
            }
        }

        function toggleSettings() {
            document.getElementById('settingsDialog').classList.toggle('hidden');
        }

        document.addEventListener('click', (e) => {
            const dialog = document.getElementById('settingsDialog');
            const btn = document.getElementById('settingsBtn');
            if (!dialog.contains(e.target) && !btn.contains(e.target)) {
                dialog.classList.add('hidden');
            }
        });

        // ========== Preview Render ==========
        editor.addEventListener('input', () => {
            renderPreview();
            updateSyncOverlay();
        });

        function renderPreview() {
            const text = editor.value;
            if (text.trim() === '') {
                preview.innerHTML = '';
                placeholder.classList.remove('hidden');
            } else {
                placeholder.classList.add('hidden');
                preview.innerHTML = marked.parse(text);
            }
        }

        // Tab support
        editor.addEventListener('keydown', function (e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 4;
                renderPreview();
            }
        });

        function copyMarkdown() {
            const text = editor.value.trim();
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('copyBtn');
                const original = btn.innerHTML;
                btn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M5 13l4 4L19 7"/></svg> Copied!';
                btn.classList.remove('bg-green-600', 'hover:bg-green-700');
                btn.classList.add('bg-emerald-500');
                setTimeout(() => {
                    btn.innerHTML = original;
                    btn.classList.remove('bg-emerald-500');
                    btn.classList.add('bg-green-600', 'hover:bg-green-700');
                }, 2000);
            });
        }

        function clearEditor() {
            editor.value = '';
            renderPreview();
            editor.focus();
        }

        // ========== Draggable Divider ==========
        const divider = document.getElementById('divider');
        const editorPanel = document.getElementById('editor-panel');
        let isDragging = false;

        divider.addEventListener('mousedown', (e) => {
            isDragging = true;
            divider.classList.add('active');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const container = editorPanel.parentElement;
            const rect = container.getBoundingClientRect();
            const offset = e.clientX - rect.left;
            const percentage = (offset / rect.width) * 100;
            editorPanel.style.width = Math.max(20, Math.min(80, percentage)) + '%';
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                divider.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });

        // ============================================================
        //  REALTIME SYNC ENGINE
        //  Maps editor source positions <-> preview text node positions
        // ============================================================

        /**
         * Walk all text nodes in the preview DOM
         */
        function getTextNodes(root) {
            const nodes = [];
            (function walk(node) {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.length > 0) {
                    nodes.push(node);
                } else {
                    for (let i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
                }
            })(root);
            return nodes;
        }

        /**
         * Strip inline markdown syntax, returning visible text
         */
        function stripInline(text) {
            text = text.replace(/!\[([^\]]*)\]\([^)]*\)/g, '$1');
            text = text.replace(/\[([^\]]*)\]\([^)]*\)/g, '$1');
            text = text.replace(/\*{3}([^*]+)\*{3}/g, '$1');
            text = text.replace(/_{3}([^_]+)_{3}/g, '$1');
            text = text.replace(/\*{2}([^*]+)\*{2}/g, '$1');
            text = text.replace(/_{2}([^_]+)_{2}/g, '$1');
            text = text.replace(/\*([^*]+)\*/g, '$1');
            text = text.replace(/_([^_]+)_/g, '$1');
            text = text.replace(/~~([^~]+)~~/g, '$1');
            text = text.replace(/`([^`]+)`/g, '$1');
            return text;
        }

        /**
         * Get visible text for a single markdown line (strip block-level syntax)
         */
        function getLineVisibleText(line) {
            let m;
            if ((m = line.match(/^#{1,6}\s+(.*)/))) return stripInline(m[1]);
            if (/^(\s*[-*_]\s*){3,}$/.test(line)) return '';
            if ((m = line.match(/^\s*[-*+]\s+(.*)/))) return stripInline(m[1]);
            if ((m = line.match(/^\s*\d+\.\s+(.*)/))) return stripInline(m[1]);
            if ((m = line.match(/^>\s?(.*)/))) return stripInline(m[1]);
            if (/^(`{3,}|~{3,})/.test(line)) return '';
            if (line.trim() === '') return '';
            return stripInline(line);
        }

        /**
         * Build a char map: for each visible character in a line,
         * return its offset within that line in the source.
         */
        function buildInlineCharMap(text, baseOffset, map) {
            let i = 0;
            while (i < text.length) {
                const rest = text.substring(i);
                let m;

                // Image ![alt](url)
                if ((m = rest.match(/^!\[([^\]]*)\]\([^)]*\)/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 2 + j);
                    i += m[0].length; continue;
                }
                // Link [text](url)
                if ((m = rest.match(/^\[([^\]]*)\]\([^)]*\)/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 1 + j);
                    i += m[0].length; continue;
                }
                // ***bold italic***
                if ((m = rest.match(/^\*{3}([^*]+)\*{3}/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 3 + j);
                    i += m[0].length; continue;
                }
                // **bold**
                if ((m = rest.match(/^\*{2}([^*]+)\*{2}/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 2 + j);
                    i += m[0].length; continue;
                }
                // *italic*
                if ((m = rest.match(/^\*([^*]+)\*/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 1 + j);
                    i += m[0].length; continue;
                }
                // ___bold italic___
                if ((m = rest.match(/^_{3}([^_]+)_{3}/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 3 + j);
                    i += m[0].length; continue;
                }
                // __bold__
                if ((m = rest.match(/^_{2}([^_]+)_{2}/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 2 + j);
                    i += m[0].length; continue;
                }
                // _italic_
                if ((m = rest.match(/^_([^_]+)_/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 1 + j);
                    i += m[0].length; continue;
                }
                // ~~strike~~
                if ((m = rest.match(/^~~([^~]+)~~/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 2 + j);
                    i += m[0].length; continue;
                }
                // `code`
                if ((m = rest.match(/^`([^`]+)`/))) {
                    for (let j = 0; j < m[1].length; j++) map.push(baseOffset + i + 1 + j);
                    i += m[0].length; continue;
                }
                // Normal char
                map.push(baseOffset + i);
                i++;
            }
        }

        function getLineCharMap(line) {
            const map = [];
            let m, contentStart = 0, content = line;

            if ((m = line.match(/^(#{1,6}\s+)/))) { contentStart = m[1].length; content = line.substring(contentStart); }
            else if ((m = line.match(/^(\s*[-*+]\s+)/))) { contentStart = m[1].length; content = line.substring(contentStart); }
            else if ((m = line.match(/^(\s*\d+\.\s+)/))) { contentStart = m[1].length; content = line.substring(contentStart); }
            else if ((m = line.match(/^(>\s?)/))) { contentStart = m[1].length; content = line.substring(contentStart); }

            buildInlineCharMap(content, contentStart, map);
            return map;
        }

        /**
         * Build complete source-offset <-> preview-text-node mapping
         */
        function buildMappings(mdText) {
            const mappings = []; // { srcIndex, node, offsetInNode }

            const textNodes = getTextNodes(preview);
            if (textNodes.length === 0) return mappings;

            // Flatten all preview text chars with node references
            const pChars = [];
            for (const tn of textNodes) {
                const t = tn.textContent;
                for (let i = 0; i < t.length; i++) {
                    pChars.push({ ch: t[i], node: tn, off: i });
                }
            }

            const srcLines = mdText.split('\n');
            let srcOffset = 0;
            let pi = 0; // pointer into pChars
            let inCodeBlock = false;

            for (const line of srcLines) {
                // Track fenced code blocks
                if (/^(`{3,}|~{3,})/.test(line.trim())) {
                    if (inCodeBlock) {
                        inCodeBlock = false;
                        srcOffset += line.length + 1;
                        continue;
                    } else {
                        inCodeBlock = true;
                        srcOffset += line.length + 1;
                        continue;
                    }
                }

                if (inCodeBlock) {
                    // Inside code block: chars map 1:1 but line is literal
                    const lineText = line;
                    if (lineText.length > 0) {
                        const matchStart = findSubstring(pChars, pi, lineText);
                        if (matchStart !== -1) {
                            for (let j = 0; j < lineText.length; j++) {
                                mappings.push({
                                    srcIndex: srcOffset + j,
                                    node: pChars[matchStart + j].node,
                                    offsetInNode: pChars[matchStart + j].off
                                });
                            }
                            pi = matchStart + lineText.length;
                        }
                    }
                    srcOffset += line.length + 1;
                    continue;
                }

                const vis = getLineVisibleText(line);
                if (vis.length === 0) {
                    srcOffset += line.length + 1;
                    continue;
                }

                const matchStart = findSubstring(pChars, pi, vis);
                if (matchStart !== -1) {
                    const charMap = getLineCharMap(line);
                    for (let vi = 0; vi < vis.length && vi < charMap.length; vi++) {
                        const pci = matchStart + vi;
                        if (pci < pChars.length) {
                            mappings.push({
                                srcIndex: srcOffset + charMap[vi],
                                node: pChars[pci].node,
                                offsetInNode: pChars[pci].off
                            });
                        }
                    }
                    pi = matchStart + vis.length;
                }

                srcOffset += line.length + 1;
            }

            return mappings;
        }

        /**
         * Find a substring within pChars starting from startIdx
         */
        function findSubstring(pChars, startIdx, text) {
            if (text.length === 0) return -1;
            const maxStart = pChars.length - text.length;
            for (let i = startIdx; i <= maxStart; i++) {
                let ok = true;
                for (let j = 0; j < text.length; j++) {
                    if (pChars[i + j].ch !== text[j]) { ok = false; break; }
                }
                if (ok) return i;
            }
            return -1;
        }

        // ========== Apply Cursor / Selection to Preview ==========

        function updateSyncOverlay() {
            if (!cursorSync && !selectionSync) return;

            const text = editor.value;
            if (text.trim() === '') return;

            // Re-render fresh DOM
            preview.innerHTML = marked.parse(text);

            const mappings = buildMappings(text);
            if (mappings.length === 0) return;

            const selStart = editor.selectionStart;
            const selEnd = editor.selectionEnd;

            if (selectionSync && selStart !== selEnd) {
                applySelection(mappings, selStart, selEnd);
            } else if (cursorSync) {
                applyCursor(mappings, selStart);
            }
        }

        function applyCursor(mappings, cursorPos) {
            // Find closest mapped position
            let bestIdx = -1, bestDist = Infinity;
            for (let i = 0; i < mappings.length; i++) {
                const d = Math.abs(mappings[i].srcIndex - cursorPos);
                if (d < bestDist) { bestDist = d; bestIdx = i; }
            }
            // Only show if cursor is very close to a visible char (within 3 chars)
            if (bestIdx === -1 || bestDist > 3) return;

            const { node, offsetInNode } = mappings[bestIdx];
            // Determine if cursor is before or after this char
            const isAfter = mappings[bestIdx].srcIndex < cursorPos;
            const insertOffset = isAfter ? offsetInNode + 1 : offsetInNode;

            insertCursorAt(node, insertOffset);
        }

        function insertCursorAt(textNode, offset) {
            const text = textNode.textContent;
            const clampedOffset = Math.min(offset, text.length);
            const before = text.substring(0, clampedOffset);
            const after = text.substring(clampedOffset);
            const parent = textNode.parentNode;

            const frag = document.createDocumentFragment();
            if (before) frag.appendChild(document.createTextNode(before));

            const cursorEl = document.createElement('span');
            cursorEl.className = 'preview-cursor';
            frag.appendChild(cursorEl);

            if (after) frag.appendChild(document.createTextNode(after));
            parent.replaceChild(frag, textNode);
        }

        function applySelection(mappings, selStart, selEnd) {
            const selected = mappings.filter(m => m.srcIndex >= selStart && m.srcIndex < selEnd);
            if (selected.length === 0) return;

            // Group by text node
            const groups = new Map();
            for (const m of selected) {
                if (!groups.has(m.node)) groups.set(m.node, []);
                groups.get(m.node).push(m.offsetInNode);
            }

            // Process in reverse order to avoid DOM invalidation
            const entries = Array.from(groups.entries()).reverse();

            for (const [node, offsets] of entries) {
                if (!node.parentNode) continue;
                offsets.sort((a, b) => a - b);

                // Build contiguous ranges
                const ranges = [];
                let rs = offsets[0], re = offsets[0];
                for (let i = 1; i < offsets.length; i++) {
                    if (offsets[i] === re + 1) { re = offsets[i]; }
                    else { ranges.push([rs, re]); rs = offsets[i]; re = offsets[i]; }
                }
                ranges.push([rs, re]);

                const text = node.textContent;
                const parent = node.parentNode;
                const frag = document.createDocumentFragment();
                let lastEnd = 0;

                for (const [s, e] of ranges) {
                    if (s > lastEnd) frag.appendChild(document.createTextNode(text.substring(lastEnd, s)));
                    const span = document.createElement('span');
                    span.className = 'preview-selection';
                    span.textContent = text.substring(s, e + 1);
                    frag.appendChild(span);
                    lastEnd = e + 1;
                }
                if (lastEnd < text.length) frag.appendChild(document.createTextNode(text.substring(lastEnd)));

                parent.replaceChild(frag, node);
            }
        }

        // ========== Editor Events for Sync ==========
        let syncRAF = null;
        function scheduleSyncUpdate() {
            if (syncRAF) cancelAnimationFrame(syncRAF);
            syncRAF = requestAnimationFrame(updateSyncOverlay);
        }

        editor.addEventListener('mouseup', scheduleSyncUpdate);
        editor.addEventListener('click', scheduleSyncUpdate);
        editor.addEventListener('select', scheduleSyncUpdate);
        editor.addEventListener('keyup', (e) => {
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(e.key) || e.shiftKey) {
                scheduleSyncUpdate();
            }
        });

        // ========== Init ==========
        function initSettings() {
            updateToggleUI('autoLoadToggle', 'toggleDot', autoLoad);
            updateToggleUI('cursorSyncToggle', 'cursorSyncDot', cursorSync);
            updateToggleUI('selectionSyncToggle', 'selectionSyncDot', selectionSync);
            if (autoLoad) editor.value = sampleMarkdown;
            renderPreview();
        }

        initSettings();
    </script>
</body>

</html>
